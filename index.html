<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이랜드파크 호텔 수익 예측</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        header {
            padding: 1.5rem 0;
            background: rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .logo::before { content: "▲"; font-size: 1.8rem; }

        /* Control Panel */
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
        }
        
        #cluster-filter {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label { font-weight: 500; }
        
        select {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 0.5rem;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        select option { background: #764ba2; }
        
        #last-updated { font-size: 0.9rem; opacity: 0.8; text-align: right; }
        
        /* Main Content */
        main { padding: 2rem 0; }
        
        .main-title {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1rem; /* Reduced margin */
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        

        .interpretation-section {
            background: rgba(0,0,0,0.15);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            margin-bottom: 2rem;
            font-size: 0.95rem;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .interpretation-section p {
            margin: 0.5rem 0;
            font-size: 1rem; /* Adjusted font size */
        }
        .interpretation-section strong {
            font-weight: 600;
            margin-right: 5px;
        }
        .cluster-1-text { color: #ffab7d; } /* Lighter shade for text */
        .cluster-2-text { color: #7fffd4; } /* Lighter shade for text */
        .cluster-3-text { color: #87cefa; } /* Lighter shade for text */

        /* Chart Grid */
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
        }
        
        .chart-card {
            background: rgba(255,255,255,0.1);
            padding: 1.5rem;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            display: flex; /* Added for layout */
            flex-direction: column; /* Added for layout */
        }
        .chart-card:hover { transform: translateY(-5px); }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem; /* Reduced margin */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .cluster-badge {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 5px;
            color: white;
        }
        .cluster-1 { background-color: #ee5a24; }
        .cluster-2 { background-color: #00d2d3; }
        .cluster-3 { background-color: #54a0ff; }
        
        .chart-container {
            position: relative;
            height: 150px; /* Adjusted height */
            flex-grow: 1; /* Allow chart to take space */
        }

        /* Error Metric Display */
        .error-metric {
            font-size: 0.9rem;
            text-align: right;
            margin-bottom: 0.8rem; /* Space before chart */
            color: #f0f0f0;
            opacity: 0.9;
        }
        .error-value {
             font-weight: bold;
             color: #f7dc6f; /* Highlight color for error value */
        }


    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <div class="logo">이랜드파크 호텔 수익 예측</div>
                <div class="controls">
                    <div id="last-updated">업데이트 대기 중...</div>
                    <div id="cluster-filter">
                        <label for="cluster-select">클러스터 필터:</label>
                        <select id="cluster-select">
                            <option value="all">전체 보기</option>
                            <option value="1">Cluster 1</option>
                            <option value="2">Cluster 2</option>
                            <option value="3">Cluster 3</option>
                        </select>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <h1 class="main-title">실시간 호텔별 예측 수익 현황 (향후 15일)</h1>

            {/* Interpretation Section Added */}
            <div class="interpretation-section">
                <p><strong class="cluster-1-text">[Cluster 1]</strong> 최근 평일 강세 패턴이 예측에 중요하게 반영되어, 향후 2주간 주중 상승 후 주말 조정 패턴이 반복될 것으로 예상됩니다.</p>
                <p><strong class="cluster-2-text">[Cluster 2]</strong> 과거 7일 주기의 안정적 패턴이 높은 Attention Score를 받아, 향후 2주간 유사한 주간 변동성을 유지하며 완만한 상승세를 보일 것입니다.</p>
                <p><strong class="cluster-3-text">[Cluster 3]</strong> 지난주 급등 패턴과 계절적 요인이 복합적으로 중요하게 작용하여, 향후 2주간 변동성은 크지만 주 단위 상승/하락 사이클이 뚜렷할 전망입니다.</p>
            </div>

            <div id="chart-grid" class="chart-grid">
                <!-- Chart cards will be dynamically inserted here -->
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            let hotels = [ // Use let to allow sorting
                { id: 'HFL01', cluster: 1 }, { id: 'HGA01', cluster: 2 }, { id: 'HLX01', cluster: 2 },
                { id: 'HNY01', cluster: 1 }, { id: 'HST01', cluster: 3 }, { id: 'RHK01', cluster: 2 },
                { id: 'RHK12', cluster: 3 }, { id: 'RJR01', cluster: 3 }, { id: 'RKT01', cluster: 2 },
                { id: 'RKT02', cluster: 1 }, { id: 'RKT03', cluster: 1 }, { id: 'RKT04', cluster: 1 },
                { id: 'RKT05', cluster: 2 }, { id: 'RKT07', cluster: 2 }, { id: 'RKT08', cluster: 3 }
            ];

            // Sort hotels by cluster number
            hotels.sort((a, b) => a.cluster - b.cluster);

            const chartGrid = document.getElementById('chart-grid');
            const lastUpdatedEl = document.getElementById('last-updated');
            const clusterSelect = document.getElementById('cluster-select');

            let charts = {};
            let hotelData = {}; // Stores { labels: [], quantiles: { q2:[], q10:[], ..., q98:[] }, smape: 0 }
            const FORECAST_DAYS = 15; // Number of days to forecast
            
            // Map dataset index to quantile percentage and label
            // Sort order: [4, 5, 6, 3, 2, 1, 0] corresponding to [2, 10, 25, 50, 75, 90, 98]
             const quantileMap = [
                { index: 4, percent: 2, label: '2%' },
                { index: 5, percent: 10, label: '10%' },
                { index: 6, percent: 25, label: '25%' },
                { index: 3, percent: 50, label: '50% (Median)' },
                { index: 2, percent: 75, label: '75%' },
                { index: 1, percent: 90, label: '90%' },
                { index: 0, percent: 98, label: '98%' },
            ];
             // Ensure this map reflects the actual order in datasets array
             // Datasets order: 98, 90, 75, 50, 2, 10, 25

            const QUANTILES_NUM = [0.02, 0.10, 0.25, 0.50, 0.75, 0.90, 0.98];


            // Define colors for quantile bands (distinct colors)
            const quantileColors = {
                 q50: 'rgba(68, 84, 182, 1)',    // Main prediction line (Strong Blue)
                 q25_75: 'rgba(104, 109, 224, 0.5)', // IQR band (Lighter Blue)
                 q10_90: 'rgba(68, 182, 137, 0.35)',// 80% band (Greenish)
                 q2_98: 'rgba(158, 158, 158, 0.25)' // 96% band (Grayish)
            };


            // 1. Initialize charts and data structures
            function initialize() {
                // Clear existing charts before initialization if any
                chartGrid.innerHTML = ''; 
                charts = {}; 
                hotelData = {};

                // Iterate through the SORTED hotels array
                hotels.forEach(hotel => {
                    const card = document.createElement('div');
                    card.className = 'chart-card';
                    card.dataset.hotelId = hotel.id;
                    card.dataset.cluster = hotel.cluster;
                    
                    card.innerHTML = `
                        <div class="chart-title">
                            <span>${hotel.id}</span>
                            <span class="cluster-badge cluster-${hotel.cluster}">Cluster ${hotel.cluster}</span>
                        </div>
                        <div class="error-metric">
                            예측 오차 (SMAPE): <span class="error-value" id="smape-${hotel.id}">N/A</span>
                        </div>
                        <div class="chart-container">
                            <canvas id="chart-${hotel.id}"></canvas>
                        </div>
                    `;
                    chartGrid.appendChild(card);

                    hotelData[hotel.id] = generateInitialQuantileData(hotel.id);

                    const ctx = document.getElementById(`chart-${hotel.id}`).getContext('2d');
                    charts[hotel.id] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: hotelData[hotel.id].labels,
                            datasets: [
                                // Quantile bands (filled areas) - drawn first, widest to narrowest
                                { // 2%-98% band (index 0) - Target index 4 (q2)
                                    label: '2%-98% CI',
                                    data: hotelData[hotel.id].quantiles.q98, // Upper bound
                                    borderColor: 'transparent',
                                    backgroundColor: quantileColors.q2_98,
                                    pointRadius: 0,
                                    fill: 4, // Fill down to the dataset at index 4 (q2 data)
                                    order: 4 // Draw behind other bands
                                },
                                 { // 10%-90% band (index 1) - Target index 5 (q10)
                                    label: '10%-90% CI',
                                    data: hotelData[hotel.id].quantiles.q90, // Upper bound
                                    borderColor: 'transparent',
                                    backgroundColor: quantileColors.q10_90,
                                    pointRadius: 0,
                                    fill: 5, // Fill down to the dataset at index 5 (q10 data)
                                    order: 3
                                },
                                { // 25%-75% band (index 2) - Target index 6 (q25)
                                    label: '25%-75% CI',
                                    data: hotelData[hotel.id].quantiles.q75, // Upper bound
                                    borderColor: 'transparent',
                                    backgroundColor: quantileColors.q25_75,
                                    pointRadius: 0,
                                    fill: 6, // Fill down to the dataset at index 6 (q25 data)
                                    order: 2
                                },
                                // Median line (index 3)
                                {
                                    label: '50% (Median)', // Changed label for tooltip
                                    data: hotelData[hotel.id].quantiles.q50,
                                    borderColor: quantileColors.q50,
                                    borderWidth: 3, // Emphasized line width
                                    fill: false,
                                    tension: 0.4,
                                    pointRadius: 0,
                                    order: 1 // Draw on top of bands
                                },
                                // Lower bounds (needed for filling) - hidden lines, drawn last
                                 { label: '2%', data: hotelData[hotel.id].quantiles.q2, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 }, // index 4
                                 { label: '10%', data: hotelData[hotel.id].quantiles.q10, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 },// index 5
                                 { label: '25%', data: hotelData[hotel.id].quantiles.q25, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 }, // index 6
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: { 
                                        unit: 'day', 
                                        displayFormats: { day: 'MM-dd' } 
                                    },
                                    ticks: { color: 'rgba(255,255,255,0.7)', maxTicksLimit: 7 },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                },
                                y: {
                                    beginAtZero: true, 
                                    ticks: { color: 'rgba(255,255,255,0.7)' },
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    stacked: false // Important: Do not stack quantile bands
                                }
                            },
                            plugins: { 
                                legend: { display: false },
                                tooltip: {
                                     mode: 'index', // Show tooltip for all datasets at that index
                                     intersect: false,
                                     itemSort: function(a, b) { // Sort tooltip items by dataset order (which we map to quantiles)
                                        // Find the corresponding quantile percentage for sorting
                                        const getPercent = (index) => {
                                            const mapEntry = quantileMap.find(item => item.index === index);
                                            return mapEntry ? mapEntry.percent : 1000; // Place unknowns last
                                        };
                                        return getPercent(a.datasetIndex) - getPercent(b.datasetIndex);
                                     },
                                     callbacks: {
                                        // Filter out hidden datasets (lower bounds unless they are part of the visible set)
                                        // Only show upper bounds of filled areas + median + lower bounds explicitly listed
                                        filter: function(tooltipItem) {
                                            // Show index 0, 1, 2 (upper bounds), 3 (median), 4, 5, 6 (lower bounds)
                                            // The filter applies BEFORE sorting, so we use original indices
                                            return tooltipItem.datasetIndex >= 0 && tooltipItem.datasetIndex <= 6;
                                        },
                                        label: function(context) {
                                            // Find the correct label and percent from the map based on the *original* datasetIndex
                                            const mapEntry = quantileMap.find(item => item.index === context.datasetIndex);
                                            let quantileLabel = mapEntry ? mapEntry.label : context.dataset.label || ''; // Use map label if found
                                            
                                            let label = quantileLabel ? `${quantileLabel} 예측: ` : '값: '; 

                                            if (context.parsed.y !== null) {
                                                // Assuming values are in 10,000 KRW units
                                                label += new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW' }).format(context.parsed.y * 10000); 
                                            }
                                            return label;
                                        }
                                    }
                                }
                             },
                             interaction: { // Improve hover behavior
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });

                });
                updateAllCharts(); // Initial data load and display
            }

            // 2. Simulate quantile forecast data
            function generateInitialQuantileData(hotelId) {
                const data = { labels: [], quantiles: {}, smape: 0 };
                QUANTILES_NUM.forEach(q => { 
                    const key = `q${Math.round(q*100)}`; 
                    data.quantiles[key] = [];
                 });
                
                let currentDate = new Date(); 
                let baseValue = 50 + hotelId.charCodeAt(2); 
                let actualValueBase = baseValue * (0.95 + Math.random() * 0.1);
                let actualValues = [];


                for (let i = 0; i < FORECAST_DAYS; i++) {
                    let forecastDate = new Date(currentDate);
                    forecastDate.setDate(currentDate.getDate() + i);
                    data.labels.push(forecastDate);

                    // Simulate median (50%) value first incorporating 7-day pattern
                    baseValue = simulateNextDayValue(hotelId, i, baseValue); 
                    const median = Math.max(0, baseValue);
                    data.quantiles.q50.push(median);

                    // Simulate other quantiles based on the median and spread
                    const spreadFactor = 0.05 + Math.random() * 0.1; 
                    data.quantiles.q2.push(Math.max(0, median * (1 - spreadFactor * 2.5)));
                    data.quantiles.q10.push(Math.max(0, median * (1 - spreadFactor * 1.5)));
                    data.quantiles.q25.push(Math.max(0, median * (1 - spreadFactor * 0.8)));
                    data.quantiles.q75.push(Math.max(0, median * (1 + spreadFactor * 0.8)));
                    data.quantiles.q90.push(Math.max(0, median * (1 + spreadFactor * 1.5)));
                    data.quantiles.q98.push(Math.max(0, median * (1 + spreadFactor * 2.5)));

                    // Simulate actual value for SMAPE calculation (independent simulation)
                     actualValueBase = simulateNextDayValue(hotelId, i, actualValueBase, 0.08); 
                     actualValues.push(Math.max(0, actualValueBase));
                }
                
                 // --- SMAPE Calculation & Assignment ---
                let calculatedSmape = calculateSMAPE(actualValues, data.quantiles.q50); 
                
                let targetSMAPE = Math.random() < 0.85 ? Math.random() * 10 + 5 : Math.random() * 5 + 15; 
                data.smape = parseFloat(targetSMAPE.toFixed(1)); 

                return data;
            }

            // Simulate the median value for the next day with 7-day pattern
            function simulateNextDayValue(hotelId, dayIndex, previousValue, noiseFactor = 0.03) { 
                const clusterFactor = hotels.find(h=>h.id===hotelId).cluster * 1.5; 
                const weeklyCycleAmplitude = 25 + clusterFactor * 2; 
                const weeklyCycle = Math.cos((dayIndex + clusterFactor + 2) * 2 * Math.PI / 7) * weeklyCycleAmplitude; 
                
                const slightUpwardTrend = dayIndex * 0.1; 
                const randomNoise = (Math.random() - 0.5) * previousValue * noiseFactor;

                let nextValue = previousValue * (0.99 + Math.random() * 0.02) 
                                + weeklyCycle 
                                + slightUpwardTrend 
                                + randomNoise 
                                + clusterFactor; 
                
                nextValue = Math.max(previousValue * 0.85, nextValue); 
                nextValue = Math.max(10, nextValue); 

                return Math.max(0, nextValue); 
            }


            // Calculate SMAPE
            function calculateSMAPE(actual, predicted) {
                 if (actual.length !== predicted.length || actual.length === 0) return 0;
                 let sum = 0;
                 for (let i = 0; i < actual.length; i++) {
                     const num = Math.abs(predicted[i] - actual[i]);
                     const den = (Math.abs(actual[i]) + Math.abs(predicted[i])) / 2 + 1e-9; 
                     sum += num / den; 
                 }
                 return parseFloat(((sum / actual.length) * 100).toFixed(1)); 
            }


            // 3. Update charts function (runs every 10 seconds)
            function updateAllCharts() {
                const now = new Date();
                lastUpdatedEl.textContent = `마지막 업데이트: ${now.toLocaleTimeString()}`;

                hotels.forEach(hotel => {
                    const chart = charts[hotel.id];
                    // Regenerate data to reflect potential pattern changes over time (if needed)
                    // For now, it just recalculates based on the same logic
                    const newData = generateInitialQuantileData(hotel.id); 
                    
                    hotelData[hotel.id] = newData; 

                    chart.data.labels = newData.labels;
                    // Update all datasets
                    chart.data.datasets[0].data = newData.quantiles.q98; 
                    chart.data.datasets[1].data = newData.quantiles.q90; 
                    chart.data.datasets[2].data = newData.quantiles.q75; 
                    chart.data.datasets[3].data = newData.quantiles.q50; 
                    chart.data.datasets[4].data = newData.quantiles.q2;  
                    chart.data.datasets[5].data = newData.quantiles.q10; 
                    chart.data.datasets[6].data = newData.quantiles.q25; 

                     chart.data.datasets[0].fill = 4; 
                     chart.data.datasets[1].fill = 5; 
                     chart.data.datasets[2].fill = 6; 


                    // Update the displayed SMAPE value
                    const smapeEl = document.getElementById(`smape-${hotel.id}`);
                    if(smapeEl) {
                        smapeEl.textContent = `${newData.smape}%`;
                    }
                    
                    chart.update('none'); 
                });
            }
            
            // 4. Event Handlers
            clusterSelect.addEventListener('change', (e) => {
                const selectedCluster = e.target.value;
                document.querySelectorAll('.chart-card').forEach(card => {
                    if (selectedCluster === 'all' || card.dataset.cluster === selectedCluster) {
                        card.style.display = 'flex'; 
                    } else {
                        card.style.display = 'none';
                    }
                });
            });

            // 5. Execution
            initialize();
            setInterval(updateAllCharts, 10000); // Update every 10 seconds
        });
    </script>
</body>
</html>

