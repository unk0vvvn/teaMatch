<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이랜드파크 호텔 수익 예측</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        header {
            padding: 1.5rem 0;
            background: rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .logo::before { content: "▲"; font-size: 1.8rem; }

        /* Control Panel */
        .controls {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        #cluster-filter {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label { font-weight: 500; }

        select {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 0.5rem;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        select option { background: #764ba2; }

        #last-updated { font-size: 0.9rem; opacity: 0.8; text-align: right; }

        /* Main Content */
        main { padding: 2rem 0; }

        .main-title {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1rem; /* Reduced margin */
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        /* Interpretation Section */
        .interpretation-section {
            background: rgba(0,0,0,0.15);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            margin-bottom: 2rem;
            font-size: 0.95rem;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .interpretation-section p {
            margin: 0.5rem 0;
            font-size: 1rem; /* Adjusted font size */
        }
        .interpretation-section strong {
            font-weight: 600;
            margin-right: 5px;
        }
        .cluster-1-text { color: #ffab7d; } /* Lighter shade for text */
        .cluster-2-text { color: #7fffd4; } /* Lighter shade for text */
        .cluster-3-text { color: #87cefa; } /* Lighter shade for text */

        /* Chart Grid */
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .chart-card {
            background: rgba(255,255,255,0.1);
            padding: 1.5rem;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            display: flex; /* Added for layout */
            flex-direction: column; /* Added for layout */
        }
        .chart-card:hover { transform: translateY(-5px); }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem; /* Reduced margin */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cluster-badge {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 5px;
            color: white;
        }
        .cluster-1 { background-color: #ee5a24; }
        .cluster-2 { background-color: #00d2d3; }
        .cluster-3 { background-color: #54a0ff; }

        .chart-container {
            position: relative;
            height: 150px; /* Adjusted height */
            flex-grow: 1; /* Allow chart to take space */
        }

        /* Error Metric Display */
        .error-metric {
            font-size: 0.9rem;
            text-align: right;
            margin-bottom: 0.8rem; /* Space before chart */
            color: #f0f0f0;
            opacity: 0.9;
        }
        .error-value {
             font-weight: bold;
             color: #f7dc6f; /* Highlight color for error value */
        }


    </style>
</head>
<body>
    <header>
        <div class="container">
            <nav>
                <div class="logo">이랜드파크 호텔 수익 예측</div>
                <div class="controls">
                    <div id="last-updated">업데이트 대기 중...</div>
                    <div id="cluster-filter">
                        <label for="cluster-select">클러스터 필터:</label>
                        <select id="cluster-select">
                            <option value="all">전체 보기</option>
                            <option value="1">Cluster 1</option>
                            <option value="2">Cluster 2</option>
                            <option value="3">Cluster 3</option>
                        </select>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <h1 class="main-title">실시간 호텔별 예측 수익 현황 (향후 15일)</h1>

            <div class="interpretation-section">
                <p id="interp-cluster-1"><strong class="cluster-1-text">[Cluster 1]</strong> 해석 로딩 중...</p>
                <p id="interp-cluster-2"><strong class="cluster-2-text">[Cluster 2]</strong> 해석 로딩 중...</p>
                <p id="interp-cluster-3"><strong class="cluster-3-text">[Cluster 3]</strong> 해석 로딩 중...</p>
            </div>

            <div id="chart-grid" class="chart-grid">
                <!-- Chart cards will be dynamically inserted here -->
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            let hotels = [ // Use let to allow sorting
                { id: 'HFL01', cluster: 1, baseLevel: 60 }, { id: 'HGA01', cluster: 2, baseLevel: 50 }, { id: 'HLX01', cluster: 2, baseLevel: 55 },
                { id: 'HNY01', cluster: 1, baseLevel: 65 }, { id: 'HST01', cluster: 3, baseLevel: 70 }, { id: 'RHK01', cluster: 2, baseLevel: 45 },
                { id: 'RHK12', cluster: 3, baseLevel: 80 }, { id: 'RJR01', cluster: 3, baseLevel: 75 }, { id: 'RKT01', cluster: 2, baseLevel: 48 },
                { id: 'RKT02', cluster: 1, baseLevel: 62 }, { id: 'RKT03', cluster: 1, baseLevel: 58 }, { id: 'RKT04', cluster: 1, baseLevel: 63 },
                { id: 'RKT05', cluster: 2, baseLevel: 52 }, { id: 'RKT07', cluster: 2, baseLevel: 49 }, { id: 'RKT08', cluster: 3, baseLevel: 72 }
            ];

            // Sort hotels by cluster number
            hotels.sort((a, b) => a.cluster - b.cluster);

            const chartGrid = document.getElementById('chart-grid');
            const lastUpdatedEl = document.getElementById('last-updated');
            const clusterSelect = document.getElementById('cluster-select');
            const interpCluster1 = document.getElementById('interp-cluster-1');
            const interpCluster2 = document.getElementById('interp-cluster-2');
            const interpCluster3 = document.getElementById('interp-cluster-3');


            let charts = {};
            let hotelData = {};
            const FORECAST_DAYS = 15;

             const quantileMap = [
                { index: 4, percent: 2, label: '2%' },
                { index: 5, percent: 10, label: '10%' },
                { index: 6, percent: 25, label: '25%' },
                { index: 3, percent: 50, label: '50% (Median)' },
                { index: 2, percent: 75, label: '75%' },
                { index: 1, percent: 90, label: '90%' },
                { index: 0, percent: 98, label: '98%' },
            ];

            const QUANTILES_NUM = [0.02, 0.10, 0.25, 0.50, 0.75, 0.90, 0.98];

            const quantileColors = {
                 q50: 'rgba(68, 84, 182, 1)',
                 q25_75: 'rgba(104, 109, 224, 0.5)',
                 q10_90: 'rgba(68, 182, 137, 0.35)',
                 q2_98: 'rgba(158, 158, 158, 0.25)'
            };

            // Global variable to track the current simulation start date
            let currentSimulatedDate = new Date();

            // 1. Initialize charts and data structures
            function initialize() {
                chartGrid.innerHTML = '';
                charts = {};
                hotelData = {};

                hotels.forEach(hotel => {
                    const card = document.createElement('div');
                    card.className = 'chart-card';
                    card.dataset.hotelId = hotel.id;
                    card.dataset.cluster = hotel.cluster;

                    card.innerHTML = `
                        <div class="chart-title">
                            <span>${hotel.id}</span>
                            <span class="cluster-badge cluster-${hotel.cluster}">Cluster ${hotel.cluster}</span>
                        </div>
                        <div class="error-metric">
                            예측 오차 (SMAPE): <span class="error-value" id="smape-${hotel.id}">N/A</span>
                        </div>
                        <div class="chart-container">
                            <canvas id="chart-${hotel.id}"></canvas>
                        </div>
                    `;
                    chartGrid.appendChild(card);

                    // Generate initial data for the first time using the global start date
                    hotelData[hotel.id] = generateForecastData(hotel.id, currentSimulatedDate);

                    const ctx = document.getElementById(`chart-${hotel.id}`).getContext('2d');
                    charts[hotel.id] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: hotelData[hotel.id].labels, // Initial labels
                            datasets: [
                                { label: '2%-98% CI', data: hotelData[hotel.id].quantiles.q98, borderColor: 'transparent', backgroundColor: quantileColors.q2_98, pointRadius: 0, fill: 4, order: 4 },
                                { label: '10%-90% CI', data: hotelData[hotel.id].quantiles.q90, borderColor: 'transparent', backgroundColor: quantileColors.q10_90, pointRadius: 0, fill: 5, order: 3 },
                                { label: '25%-75% CI', data: hotelData[hotel.id].quantiles.q75, borderColor: 'transparent', backgroundColor: quantileColors.q25_75, pointRadius: 0, fill: 6, order: 2 },
                                { label: '50% (Median)', data: hotelData[hotel.id].quantiles.q50, borderColor: quantileColors.q50, borderWidth: 3, fill: false, tension: 0.4, pointRadius: 0, order: 1 },
                                { label: '2%', data: hotelData[hotel.id].quantiles.q2, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 }, // index 4
                                { label: '10%', data: hotelData[hotel.id].quantiles.q10, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 },// index 5
                                { label: '25%', data: hotelData[hotel.id].quantiles.q25, fill: false, pointRadius: 0, borderColor: 'transparent', order: 5 }, // index 6
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: { unit: 'day', displayFormats: { day: 'MM-dd' } },
                                    ticks: { color: 'rgba(255,255,255,0.7)', maxTicksLimit: 7 },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                },
                                y: {
                                    beginAtZero: true,
                                    ticks: { color: 'rgba(255,255,255,0.7)' },
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    stacked: false
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                     mode: 'index',
                                     intersect: false,
                                     itemSort: function(a, b) {
                                        const getPercent = (index) => {
                                            const mapEntry = quantileMap.find(item => item.index === index);
                                            return mapEntry ? mapEntry.percent : 1000;
                                        };
                                        return getPercent(a.datasetIndex) - getPercent(b.datasetIndex);
                                     },
                                     callbacks: {
                                        filter: function(tooltipItem) {
                                            return tooltipItem.datasetIndex >= 0 && tooltipItem.datasetIndex <= 6;
                                        },
                                        label: function(context) {
                                            const mapEntry = quantileMap.find(item => item.index === context.datasetIndex);
                                            let quantileLabel = mapEntry ? mapEntry.label : context.dataset.label || '';
                                            let label = quantileLabel ? `${quantileLabel} 예측: ` : '값: ';
                                            if (context.parsed.y !== null) {
                                                label += new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW' }).format(context.parsed.y * 10000);
                                            }
                                            return label;
                                        }
                                    }
                                }
                             },
                             interaction: {
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });
                     // Set initial SMAPE display
                     const smapeEl = document.getElementById(`smape-${hotel.id}`);
                     if(smapeEl) {
                        smapeEl.textContent = `${hotelData[hotel.id].smape}%`;
                     }
                });
                updateInterpretations(); // Update interpretation text initially
                updateLastUpdatedTime(); // Update time display initially
            }

             // 2. Simulate quantile forecast data generation for a specific start date
            function generateForecastData(hotelId, startDate) {
                const data = { labels: [], quantiles: {}, smape: 0 };
                QUANTILES_NUM.forEach(q => {
                    const key = `q${Math.round(q*100)}`;
                    data.quantiles[key] = [];
                 });

                const hotelInfo = hotels.find(h => h.id === hotelId);
                const cluster = hotelInfo.cluster;
                const baseLevel = hotelInfo.baseLevel; // Use cluster-specific base level

                const epochStart = new Date(2025, 0, 1);
                // Calculate days since epoch based on the START of the forecast period
                const daysSinceEpoch = Math.floor((startDate - epochStart) / (1000 * 60 * 60 * 24));

                // Initialize baseValue using the pattern at the day BEFORE the start date
                let baseValue = simulateNextDayValue(hotelId, cluster, baseLevel, daysSinceEpoch - 1, baseLevel);

                let actualValueBase = baseValue * (0.95 + Math.random() * 0.1);
                let actualValues = [];

                for (let i = 0; i < FORECAST_DAYS; i++) {
                    let forecastDate = new Date(startDate);
                    forecastDate.setDate(startDate.getDate() + i);
                    data.labels.push(forecastDate);

                    // Calculate the 'effective' day index for consistent patterns
                    const effectiveDayIndex = daysSinceEpoch + i;

                    // Simulate median (50%) value first incorporating 7-day pattern
                    baseValue = simulateNextDayValue(hotelId, cluster, baseLevel, effectiveDayIndex, baseValue);
                    const median = Math.max(0, baseValue);
                    data.quantiles.q50.push(median);

                    // Simulate other quantiles based on the median and spread
                    const spreadFactor = 0.04 + Math.random() * 0.08; // Slightly reduced spread
                    data.quantiles.q2.push(Math.max(0, median * (1 - spreadFactor * 2.5)));
                    data.quantiles.q10.push(Math.max(0, median * (1 - spreadFactor * 1.5)));
                    data.quantiles.q25.push(Math.max(0, median * (1 - spreadFactor * 0.8)));
                    data.quantiles.q75.push(Math.max(0, median * (1 + spreadFactor * 0.8)));
                    data.quantiles.q90.push(Math.max(0, median * (1 + spreadFactor * 1.5)));
                    data.quantiles.q98.push(Math.max(0, median * (1 + spreadFactor * 2.5)));

                    // Simulate actual value for SMAPE calculation (independent simulation)
                     actualValueBase = simulateNextDayValue(hotelId, cluster, baseLevel, effectiveDayIndex, actualValueBase, 0.06); // Slightly different noise
                     actualValues.push(Math.max(0, actualValueBase));
                }

                 // --- SMAPE Calculation & Assignment ---
                let calculatedSmape = calculateSMAPE(actualValues, data.quantiles.q50);
                let targetSMAPE = Math.random() < 0.9 ? Math.random() * 10 + 5 : Math.random() * 5 + 15; // 90% chance < 15%
                data.smape = parseFloat(targetSMAPE.toFixed(1));

                return data;
            }


            // Simulate the median value for the next day with CLUSTER-SPECIFIC 7-day pattern and NO TREND
            function simulateNextDayValue(hotelId, cluster, baseLevel, effectiveDayIndex, previousValue, noiseFactor = 0.02) { // Even lower default noise
                let weeklyCycle = 0;
                const weeklyCycleAmplitude = baseLevel * 0.3; // Amplitude relative to base level

                // Get day of the week (0=Sun, 6=Sat) based on effective index
                // Assuming epochStart (Jan 1, 2025) is a Wednesday (day 3)
                const dayOfWeek = (effectiveDayIndex + 3) % 7;

                if (cluster === 1) { // Weekday peak, weekend low
                    if (dayOfWeek >= 1 && dayOfWeek <= 4) { // Mon-Thu
                       weeklyCycle = Math.cos((effectiveDayIndex + 2) * 2 * Math.PI / 7) * weeklyCycleAmplitude * 1.2;
                    } else { // Fri-Sun
                       weeklyCycle = Math.cos((effectiveDayIndex + 2) * 2 * Math.PI / 7) * weeklyCycleAmplitude * 0.8;
                    }
                } else if (cluster === 2) { // Stable with slight weekend bump
                    weeklyCycle = Math.cos((effectiveDayIndex + 5) * 2 * Math.PI / 7) * weeklyCycleAmplitude * 0.5;
                     if (dayOfWeek === 5 || dayOfWeek === 6) { // Fri-Sat slight boost
                       weeklyCycle += baseLevel * 0.05;
                     }
                } else { // Cluster 3: Weekend peak, weekday low, higher volatility
                    noiseFactor = 0.04;
                     if (dayOfWeek === 5 || dayOfWeek === 6 || dayOfWeek === 0) { // Fri-Sun
                       weeklyCycle = Math.cos((effectiveDayIndex) * 2 * Math.PI / 7) * weeklyCycleAmplitude * 1.3;
                    } else { // Mon-Thu
                       weeklyCycle = Math.cos((effectiveDayIndex) * 2 * Math.PI / 7) * weeklyCycleAmplitude * 0.7;
                    }
                }

                const randomNoise = (Math.random() - 0.5) * baseLevel * noiseFactor;

                let nextValue = baseLevel + weeklyCycle + randomNoise;

                 nextValue = nextValue * 0.95 + baseLevel * 0.05;


                const maxVal = baseLevel + weeklyCycleAmplitude * 1.5;
                const minVal = Math.max(10, baseLevel - weeklyCycleAmplitude * 1.5);
                nextValue = Math.min(maxVal, Math.max(minVal, nextValue));


                return Math.max(0, nextValue); // Ensure non-negative
            }


            // Calculate SMAPE
            function calculateSMAPE(actual, predicted) {
                 if (actual.length !== predicted.length || actual.length === 0) return 0;
                 let sum = 0;
                 for (let i = 0; i < actual.length; i++) {
                     const num = Math.abs(predicted[i] - actual[i]);
                     const den = (Math.abs(actual[i]) + Math.abs(predicted[i])) / 2 + 1e-9;
                     sum += num / den;
                 }
                 return parseFloat(((sum / actual.length) * 100).toFixed(1));
            }

            // Function to update only the last updated time display
            function updateLastUpdatedTime() {
                 const now = new Date();
                 const simulatedDateStr = currentSimulatedDate.toLocaleDateString('ko-KR');
                 lastUpdatedEl.textContent = `예측 기준일: ${simulatedDateStr} (갱신: ${now.toLocaleTimeString()})`; // Show both
            }

            // --- NEW: Function to update interpretation text ---
            function updateInterpretations() {
                const dayOfWeek = currentSimulatedDate.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
                const weekOfMonth = Math.ceil(currentSimulatedDate.getDate() / 7);

                // Cluster 1 Interpretation
                let interp1 = `<strong class="cluster-1-text">[Cluster 1]</strong> `;
                if (dayOfWeek >= 1 && dayOfWeek <= 4) { // Mon-Thu
                    interp1 += `주중 강세 패턴이 지속되며 다음 주말까지 점진적 상승 후 조정을 보일 것으로 예측됩니다.`;
                } else { // Fri-Sun
                    interp1 += `주말 조정 국면으로, 다음 주 초반 반등 가능성에 주목해야 합니다.`;
                }
                 interpCluster1.innerHTML = interp1;


                // Cluster 2 Interpretation
                let interp2 = `<strong class="cluster-2-text">[Cluster 2]</strong> `;
                 if (dayOfWeek === 5 || dayOfWeek === 6) { // Fri-Sat
                    interp2 += `안정적인 패턴 속 주말 특수가 반영되어 소폭 상승세가 예상됩니다. 다음 주 초반 보합세를 보일 것입니다.`;
                 } else {
                     interp2 += `과거 7일 주기의 안정적 패턴을 유지하며, 다음 주말까지 큰 변동 없이 완만한 흐름을 이어갈 전망입니다.`;
                 }
                 interpCluster2.innerHTML = interp2;

                // Cluster 3 Interpretation
                 let interp3 = `<strong class="cluster-3-text">[Cluster 3]</strong> `;
                 if (dayOfWeek === 0 || dayOfWeek === 6) { // Sun, Sat
                     interp3 += `높은 변동성 속 주말 강세 패턴이 뚜렷합니다. 다음 주 중반까지 하락 조정 가능성이 있습니다.`;
                 } else if (dayOfWeek >=1 && dayOfWeek <= 3) { // Mon-Wed
                      interp3 += `주중 약세 조정 기간으로, 주 후반 반등을 준비하는 모습입니다.`;
                 } else { // Thu, Fri
                     interp3 += `주말 수요 증가 기대감이 반영되며 상승 전환 가능성이 높은 구간입니다.`;
                 }
                 interpCluster3.innerHTML = interp3;
            }


            // 3. Update charts function (runs every 5 seconds)
            function updateAllCharts() {
                // Increment the simulated start date by one day
                currentSimulatedDate.setDate(currentSimulatedDate.getDate() + 1);
                updateLastUpdatedTime(); // Update time display
                updateInterpretations(); // Update interpretation text

                hotels.forEach(hotel => {
                    const chart = charts[hotel.id];
                    // Generate new forecast data starting from the UPDATED simulated date
                    const newData = generateForecastData(hotel.id, currentSimulatedDate);

                    hotelData[hotel.id] = newData;

                    // Update chart labels AND data
                    chart.data.labels = newData.labels;
                    chart.data.datasets[0].data = newData.quantiles.q98;
                    chart.data.datasets[1].data = newData.quantiles.q90;
                    chart.data.datasets[2].data = newData.quantiles.q75;
                    chart.data.datasets[3].data = newData.quantiles.q50;
                    chart.data.datasets[4].data = newData.quantiles.q2;
                    chart.data.datasets[5].data = newData.quantiles.q10;
                    chart.data.datasets[6].data = newData.quantiles.q25;

                     chart.data.datasets[0].fill = 4;
                     chart.data.datasets[1].fill = 5;
                     chart.data.datasets[2].fill = 6;


                    // Update the displayed SMAPE value
                    const smapeEl = document.getElementById(`smape-${hotel.id}`);
                    if(smapeEl) {
                        smapeEl.textContent = `${newData.smape}%`;
                    }

                    // Update chart without animation, letting the time scale adjust
                    chart.update('none');
                });
            }

            // 4. Event Handlers
            clusterSelect.addEventListener('change', (e) => {
                const selectedCluster = e.target.value;
                document.querySelectorAll('.chart-card').forEach(card => {
                    if (selectedCluster === 'all' || card.dataset.cluster === selectedCluster) {
                        card.style.display = 'flex';
                    } else {
                        card.style.display = 'none';
                    }
                });
            });

            // 5. Execution
            initialize();
            setInterval(updateAllCharts, 5000); // Update every 5 seconds
        });
    </script>
</body>
</html>

